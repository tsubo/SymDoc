# コントローラ

コントローラはあなたが作成する [PHP コールバック](http://php.net/manual/ja/language.types.callable.php)です。それは、HTTP リクエストから情報を取得し、HTTP レスポンス（Symfony レスポンスオブジェクトとしての）を作成して返します。レスポンスは HTTP ページかもしれませんし、XML ドキュメントや、シリアライズされた JSON 配列、画像、リダイレクト、404 エラーになるかもしれません。もしくは、あなたが作り上げる何かかもしれません。
コントローラには、アプリケーションがページのコンテンツを表示するのに必要なロジックを詰め込みます。

Symfony コントローラにあるアクションを覗き込んで、それが、どれだけシンプルかを見てください。
次のサンプルは有名な `Hello world!` を表示するページをレンダリングしています。

<code php>
use Symfony\Component\HttpFoundation\Response;

public function helloAction()
{
    return new Response('Hello world!');
}
</code>

コントローラの目的はいつも同じです。レスポンスオブジェクトを作成して、それを返すことです。
順を追っていくと、コントローラはリクエストから情報を読み込んだり、データベースのリソースを読み込んだり、メールを送ったり、セッションに情報をセットしたりするかもしれません。しかし、全ての場合において、コントローラは最終的にクライアントに配信されるレスポンスオブジェクトを返します。

以下に、よくある事例を示します。

- コントローラ A は、このサイトのホームページのコンテンツを表すレスポンスオブジェクトを準備します。
- コントローラ B は、データーベースからブログエントリを読み込む為に、リクエストから `slug` パラメータを読み込みます。そして、ブログを表示するレスポンスオブジェクトを作成します。もし、`slug` がデータベースに見つからなかった時は、404 ステータスコードと共にレスポンスオブジェクトを作成し、それを返します。
- コントローラ C は、コンタクトフォームからの送信を取り扱います。コントローラはリクエストからフォームの情報を読み込み、コンタクト情報をデータベースに保存します。そして、コンタクト情報をあなたにメールします。最後に、コントローラは "Thank you" ページ（送信完了ページ）へクライアントのブラウザをリダイレクトするレスポンスオブジェクトを作成します。





## リクエスト、コントローラ、レスポンスのライフサイクル

Symfony プロジェクトが取り扱う全てのリクエストは、同じシンプルなライフサイクルをたどります。
フレームワークが繰り返し行われる処理の面倒を見てくれるので、あなたが行うのは、コントローラの関数に自身のコードを書くことだけです。

1. 各リクエストは１つのフロントコントローラファイル（例、`web/app.php` や `web/app_dev.php`）によって、取り扱われます。このファイルはアプリケーションを起動します。
2. ルーターがリクエストから情報（例、URI）を読み込みます。ルーターは情報にマッチするルートを検索します。そして、ルートから `_controller` パラメータを読み込みます。
3. ルートにマッチしたコントローラが実行されます。そして、コントローラ内のコードはレスポンスオブジェクトを作成して、それを返します。
4. HTTP ヘッダーとレスポンスオブジェクトのコンテンツはクライアントに送り返されます。

ページを作成することは、コントローラの作成(#3)や、コントローラへ URL をマップする為のルートを作成すること(#2)と同じくらい簡単です。

> 名前が似ていますが、「フロントコントローラ」はこの章で説明している「コントローラ」とは別の物です。
> フロントコントローラは "web/" ディレクトリに置いてある、短い PHP ファイルです。そして、そのファイルを通して全てのリクエストは処理されます。
> 一般的なアプリケーションは本番環境用のフロントコントローラ（app.php）と開発環境用のフロントコントローラ（app_dev.php）を持っています。
> 多分、あなたがアプリケーションのフロントコントローラを編集したり、見たり、気にかける必要はないと思います。



## シンプルなコントローラ

コントローラには [PHP コールバック](http://php.net/manual/ja/language.types.callable.php)（関数、オブジェクトのクラス、クロージャ）の何れかがなることが出来るのですが、普通はコントローラクラス内のメソッドになります。コントローラはまた、アクションとも呼ばれています。

<code php>
// src/AppBundle/Controller/HelloController.php
namespace AppBundle\Controller;

use Symfony\Component\HttpFoundation\Response;

class HelloController
{
    public function indexAction($name)
    {
        return new Response('<html><body>Hello '.$name.'!</body></html>');
    }
}
</code>

> 上の例の場合、コントローラは、コントローラクラス（HelloController）内にある indexAction メソッドであることに注意してください。
> ネーミングで混乱しないでください。コントローラクラスは複数のコントローラ/アクションを一緒にグルーピングする為のシンプルで便利な方法です。
> 一般的に、コントローラクラスは複数のコントローラ/アクションを収容します。（例、updateAction, deleteAction 等々）

このコントローラは非常に簡単です。  
※ 以下のコードのコメントに注目してください。

<code php>

// src/AppBundle/Controller/HelloController.php

// コントローラクラス内で PHP のネームスペース機能を使用しています。
namespace AppBundle\Controller;

// Response クラスをインポートしています。（ネームスペース関連の機能です）
use Symfony\Component\HttpFoundation\Response;

// コントローラクラス名は "Controller" で終わるように命名します。これは一貫性を持たせるための規約です。
// このクラスは、ルーティング設定内で、クラス名の最初の部分（"Hello")だけを使って参照されます。
class HelloController
{
    // アクション名は "Action" で終わるように命名します。
    // このアクションは、ルーティング設定内で、アクション名の最初の部分（"index")だけを使って、参照されます。
    // 次のセクションでこのアクションに URI をマップするルートを作成します。
    // そして、どの様な仕組みで $name 引数を受け取るかを学びます。
    public function indexAction($name)
    {
        // レスポンスオブジェクトを作成して、返します。
        return new Response('<html><body>Hello '.$name.'!</body></html>');
    }
}
</code>


## コントローラへの URL マッピング

### コントローラの引数としてのルートパラメータ

### コントローラの引数としてのリクエスト

## 基本コントローラクラス

### リダイレクト

### テンプレートの表示

### サービスへのアクセス

## エラーと404ページの管理

## セッション管理

### フラッシュメッセージ

## レスポンスオブジェクト

## リクエストオブジェクト

## 静的ページの作成

## 他のコントローラへの転送

## CSRF トークンのチェック

## まとめ

## クックブックから学ぶ

